import{r as y,j as h}from"./launchpad.js";import{F as at}from"./launchpad-CheckCircleIcon-D2sCnQx5.js";import{u as ye,m as st}from"./launchpad-ModalHeader-JjfRejxC-gvXxgADS.js";import{c as it,n as rt,s as ot,t as lt}from"./launchpad-Layouts-BlFm53ED-HTJjrY9f.js";import{o as Me}from"./launchpad-ScreenHeader-CHmc4-Lu-Bz0hvEfr.js";import{t as ve}from"./launchpad-FundWalletMethodHeader-DRH4o4R5-FwbuUnGj.js";import{i as ct}from"./launchpad-InjectedWalletIcon-DLcYOGDj-DM-O-Fpn.js";import{t as dt}from"./launchpad-index-Dq_xe9dz-bxbF5Mdc.js";import{t as ut,s as gt,e as ft,n as pt}from"./launchpad-Value-tcJV9e0L-rc9R0DBN.js";import{d6 as K,dj as ht,fc as mt,da as wt,fn as me,d5 as Qe,d4 as we,eh as xe,dd as P,d9 as $,fo as Ce,dV as Fe,fp as At,fq as yt,f9 as vt,fr as Ye,fs as Ke,ft as St,fu as Se,e4 as Tt,fv as It,fd as Oe,fw as bt,fx as Et,fy as Ot,fz as jt,fA as Ue,fB as Wt,fC as xt,dl as Pe,fa as $e,fD as De,fE as Ct,fF as Ne,dg as Ft,fe as Le,fG as Te,ff as Be,fH as Re,fI as _t}from"./launchpad-App-D179iYht.js";import{d as ze,f as he,c as Mt,u as Ut,p as Pt,l as pe}from"./launchpad-useSolanaRpcClient-ign2YXAl-BQKFlUzw.js";import{c as $t}from"./launchpad-useGetTokenPrice-PWP-Uiot-DSryU3xF.js";import{t as Dt}from"./launchpad-analytics-mkkvFRju-DOXuftJB.js";import{C as fe,e as ke,s as Nt}from"./launchpad-getFormattedUsdFromLamports-B6EqSEho-C-HCdwKa.js";import{r as Lt}from"./launchpad-getUsdcMintAddress-DFI1hv05-DwqfiN48.js";import{e as Bt}from"./launchpad-getChainName-DjpPdUSc-c2urPd0g.js";import{n as Ie}from"./launchpad-formatters-_15u2lww.js";import"./launchpad-WalletIcon-CmQNtWKM.js";import"./launchpad-LoadingSkeleton-U6-3yFwI-De_7LaVb.js";import"./launchpad-useGetSolPrice-DwwjjGbd-C6EP3HJh.js";const Je=()=>{let{walletProxy:e,client:n}=K();return y.useMemo(()=>({signWithUserSigner:async({message:a,targetAppId:l})=>{if(!e)throw Error("Wallet proxy not initialized");let d=await n.getAccessToken();if(!d)throw Error("User must be authenticated");let{signature:o}=await e.signWithUserSigner({accessToken:d,message:a,targetAppId:l});return{signature:o}}}),[e,n])},Ze=["solana:mainnet","solana:devnet","solana:testnet"];function Rt(e){return mt().decode(e)}function J(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var kt=0,D="__private_"+kt+++"__implementation";function U(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var Vt=0;function z(e){return"__private_"+Vt+++"_"+e}var Z=z("_address"),q=z("_publicKey"),X=z("_chains"),ee=z("_features"),te=z("_label"),ne=z("_icon");class _e{get address(){return U(this,Z)[Z]}get publicKey(){return U(this,q)[q].slice()}get chains(){return U(this,X)[X].slice()}get features(){return U(this,ee)[ee].slice()}get label(){return U(this,te)[te]}get icon(){return U(this,ne)[ne]}constructor({address:n,publicKey:a,label:l,icon:d}){Object.defineProperty(this,Z,{writable:!0,value:void 0}),Object.defineProperty(this,q,{writable:!0,value:void 0}),Object.defineProperty(this,X,{writable:!0,value:void 0}),Object.defineProperty(this,ee,{writable:!0,value:void 0}),Object.defineProperty(this,te,{writable:!0,value:void 0}),Object.defineProperty(this,ne,{writable:!0,value:void 0}),U(this,Z)[Z]=n,U(this,q)[q]=a,U(this,X)[X]=Ze,U(this,te)[te]=l,U(this,ne)[ne]=d,U(this,ee)[ee]=["solana:signAndSendTransaction","solana:signTransaction","solana:signMessage"],new.target===_e&&Object.freeze(this)}}function s(e,n){if(!Object.prototype.hasOwnProperty.call(e,n))throw TypeError("attempted to use private field on non-instance");return e}var Gt=0;function T(e){return"__private_"+Gt+++"_"+e}var F=T("_listeners"),ae=T("_version"),se=T("_name"),ie=T("_icon"),E=T("_injection"),re=T("_isPrivyWallet"),H=T("_accounts"),oe=T("_on"),Q=T("_emit"),be=T("_off"),Y=T("_connected"),le=T("_connect"),ce=T("_disconnect"),de=T("_signMessage"),ue=T("_signAndSendTransaction"),ge=T("_signTransaction");function Ht(e,...n){s(this,F)[F][e]?.forEach(a=>a.apply(null,n))}function Qt(e,n){s(this,F)[F][e]=s(this,F)[F][e]?.filter(a=>n!==a)}function Yt(e,n,a){let l=structuredClone(Tt().decode(e)),d=It(n);return d in l.signatures&&(l.signatures[d]=a),new Uint8Array(Oe().encode(l))}function qe(){let{isHeadlessSigning:e,walletProxy:n,initializeWalletProxy:a,recoverEmbeddedWallet:l,openModal:d,privy:o,client:i}=K(),{user:t}=me(),{setModalData:r}=we(),{signWithUserSigner:u}=Je();return{signMessage:({message:c,address:w,options:I})=>new Promise(async(N,O)=>{let p=xe(t,w);if(p?.walletClientType!=="privy")return void O(new P("Wallet is not a Privy wallet",void 0,$.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:A,entropyIdVerifier:S}=Fe(t,p),b=Ce(p),m=he(c).toString("base64");if(m.length<1)return void O(new P("Message must be a non-empty string",void 0,$.INVALID_MESSAGE));let x=async()=>{let f;if(!t)throw Error("User must be authenticated before signing with a Privy wallet");let _=await i.getAccessToken();if(!_)throw Error("User must be authenticated to use their embedded wallet.");let C=n??await a(15e3);if(!C)throw Error("Failed to initialize embedded wallet proxy.");if(!await l({address:p.address}))throw Error("Unable to connect to wallet");if(b){let M=await Ye(o,u,{chain_type:"solana",method:"signMessage",params:{message:m,encoding:"base64"},wallet_id:p.id});if(!M.data||!("signature"in M.data))throw Error("Failed to sign message");f=M.data.signature}else{let{response:M}=await C.rpc({accessToken:_,entropyId:A,entropyIdVerifier:S,chainType:"solana",hdWalletIndex:p.walletIndex??0,requesterAppId:I?.uiOptions?.requesterAppId,request:{method:"signMessage",params:{message:m}}});f=M.data.signature}return f};if(e({showWalletUIs:I?.uiOptions?.showWalletUIs}))try{let f=await x(),_=new Uint8Array(he(f,"base64"));N({signature:_})}catch(f){O(f)}else r({signMessage:{method:"solana_signMessage",data:m,confirmAndSign:x,onSuccess:f=>{N({signature:new Uint8Array(he(f,"base64"))})},onFailure:f=>{O(f)},uiOptions:I?.uiOptions??{}},connectWallet:{recoveryMethod:p.recoveryMethod,connectingWalletAddress:p.address,entropyId:A,entropyIdVerifier:S,isUnifiedWallet:b,onCompleteNavigateTo:"SignRequestScreen",onFailure:f=>{O(new P("Failed to connect to wallet",f,$.UNKNOWN_CONNECT_WALLET_ERROR))}}}),d("EmbeddedWalletConnectingScreen")})}}function Ve(){let{isHeadlessSigning:e,openModal:n}=K(),{setModalData:a}=we(),{signMessage:l}=qe(),{user:d}=me();return{signTransaction:async({transaction:o,options:i,chain:t="solana:mainnet",address:r})=>{async function u(c){let{signature:w}=await l({message:Mt(c),address:r,options:{...i,uiOptions:{...i?.uiOptions,showWalletUIs:!1}}});return{signedTransaction:Yt(c,r,w)}}return e({showWalletUIs:i?.uiOptions?.showWalletUIs})?u(o):new Promise(async(c,w)=>{let I=xe(d,r);if(I?.walletClientType!=="privy")return void w(new P("Wallet is not a Privy wallet",void 0,$.EMBEDDED_WALLET_NOT_FOUND));let{entropyId:N,entropyIdVerifier:O}=Fe(d,I),p=Ce(I);function A(b){return m=>{w(m instanceof P?m:new P("Failed to connect to wallet",m,b))}}let S={account:I,transaction:o,chain:t,signOnly:!0,uiOptions:i?.uiOptions||{},onConfirm:u,onSuccess:c,onFailure:A($.TRANSACTION_FAILURE)};a({connectWallet:{recoveryMethod:I.recoveryMethod,connectingWalletAddress:I.address,entropyId:N,entropyIdVerifier:O,isUnifiedWallet:p,onCompleteNavigateTo:"StandardSignAndSendTransactionScreen",onFailure:A($.UNKNOWN_CONNECT_WALLET_ERROR)},standardSignAndSendTransaction:S}),n("EmbeddedWalletConnectingScreen")})}}}let je=new class extends St{setImplementation(e){J(this,D)[D]=e}async signMessage(e){return J(this,D)[D].signMessage(e)}async signAndSendTransaction(e){return J(this,D)[D].signAndSendTransaction(e)}async signTransaction(e){return J(this,D)[D].signTransaction(e)}constructor(e){super(),Object.defineProperty(this,D,{writable:!0,value:void 0}),J(this,D)[D]=e}}({signTransaction:Se("signTransaction was not injected"),signAndSendTransaction:Se("signAndSendTransaction was not injected"),signMessage:Se("signMessage was not injected")}),Ge=new class{get version(){return s(this,ae)[ae]}get name(){return s(this,se)[se]}get icon(){return s(this,ie)[ie]}get chains(){return Ze.slice()}get features(){return{"standard:connect":{version:"1.0.0",connect:s(this,le)[le]},"standard:disconnect":{version:"1.0.0",disconnect:s(this,ce)[ce]},"standard:events":{version:"1.0.0",on:s(this,oe)[oe]},"solana:signAndSendTransaction":{version:"1.0.0",supportedTransactionVersions:["legacy",0],signAndSendTransaction:s(this,ue)[ue]},"solana:signTransaction":{version:"1.0.0",supportedTransactionVersions:["legacy",0],signTransaction:s(this,ge)[ge]},"solana:signMessage":{version:"1.0.0",signMessage:s(this,de)[de]},"privy:":{privy:{signMessage:s(this,E)[E].signMessage,signTransaction:s(this,E)[E].signTransaction,signAndSendTransaction:s(this,E)[E].signAndSendTransaction}}}}get accounts(){return s(this,H)[H].slice()}get isPrivyWallet(){return s(this,re)[re]}constructor({name:e,icon:n,version:a,injection:l,wallets:d}){Object.defineProperty(this,Q,{value:Ht}),Object.defineProperty(this,be,{value:Qt}),Object.defineProperty(this,F,{writable:!0,value:void 0}),Object.defineProperty(this,ae,{writable:!0,value:void 0}),Object.defineProperty(this,se,{writable:!0,value:void 0}),Object.defineProperty(this,ie,{writable:!0,value:void 0}),Object.defineProperty(this,E,{writable:!0,value:void 0}),Object.defineProperty(this,re,{writable:!0,value:void 0}),Object.defineProperty(this,H,{writable:!0,value:void 0}),Object.defineProperty(this,oe,{writable:!0,value:void 0}),Object.defineProperty(this,Y,{writable:!0,value:void 0}),Object.defineProperty(this,le,{writable:!0,value:void 0}),Object.defineProperty(this,ce,{writable:!0,value:void 0}),Object.defineProperty(this,de,{writable:!0,value:void 0}),Object.defineProperty(this,ue,{writable:!0,value:void 0}),Object.defineProperty(this,ge,{writable:!0,value:void 0}),s(this,F)[F]={},s(this,oe)[oe]=(o,i)=>(s(this,F)[F][o]?.push(i)||(s(this,F)[F][o]=[i]),()=>s(this,be)[be](o,i)),s(this,Y)[Y]=o=>{o!=null&&(s(this,H)[H]=o.map(({address:i})=>new _e({address:i,publicKey:Ke.decode(i)}))),s(this,Q)[Q]("change",{accounts:this.accounts})},s(this,le)[le]=async()=>(s(this,Q)[Q]("change",{accounts:this.accounts}),{accounts:this.accounts}),s(this,ce)[ce]=async()=>{s(this,Q)[Q]("change",{accounts:this.accounts})},s(this,de)[de]=async(...o)=>{let i=[];for(let{account:t,...r}of o){let{signature:u}=await s(this,E)[E].signMessage({...r,address:t.address});i.push({signedMessage:r.message,signature:u})}return i},s(this,ue)[ue]=async(...o)=>{let i=[];for(let t of o){let{signature:r}=await s(this,E)[E].signAndSendTransaction({...t,transaction:t.transaction,address:t.account.address,chain:t.chain||"solana:mainnet",options:t.options});i.push({signature:r})}return i},s(this,ge)[ge]=async(...o)=>{let i=[];for(let{transaction:t,account:r,options:u,chain:c}of o){let{signedTransaction:w}=await s(this,E)[E].signTransaction({transaction:t,address:r.address,chain:c||"solana:mainnet",options:u});i.push({signedTransaction:w})}return i},s(this,se)[se]=e,s(this,ie)[ie]=n,s(this,ae)[ae]=a,s(this,E)[E]=l,s(this,H)[H]=[],s(this,re)[re]=!0,l.on("accountChanged",s(this,Y)[Y],this),s(this,Y)[Y](d)}}({name:"Privy",version:"1.0.0",icon:"data:image/png;base64,AAABAAEAFBQAAAAAIABlAQAAFgAAAIlQTkcNChoKAAAADUlIRFIAAAAUAAAAFAgGAAAAjYkdDQAAAAlwSFlzAAAOwwAADsMBx2+oZAAAAQVJREFUeJxiYMANZIC4E4ivAPFPIP4FxDeAuB+IlfDowwBMQFwJxF+B+D8O/AOI66Bq8QJGIF6ExyB0vAqImfEZmEeCYTDcgMswPiB+T4aB34FYApuBsWQYBsP52AycToGBK7EZuJECAw9jM3AVBQbuwWZgIwUGTsZmoDkFBnpiMxAEjpJh2FV8iVsbiD+TYBgoDVrgMgwGnID4HRGGgTKBGyHDYEAaiBdCSxh0g/5AU4Q8sYYhAzEgjoGmABBOgFo2eACowFABYn0oVgViAVINkQTiZUD8DIj/ATF6GILEXgLxCiCWIsZAbiAuBeKtQHwHiEHJ6C8UfwHie0C8E4jLoWpRAAAAAP//rcbhsQAAAAZJREFUAwBYFs3VKJ0cuQAAAABJRU5ErkJggg==",wallets:[],injection:je});function Kt(){let{ready:e}=wt(),{user:n}=me(),{signMessage:a}=qe(),{signTransaction:l}=Ve(),{signAndSendTransaction:d}=function(){let t=Qe(),{isHeadlessSigning:r,openModal:u,privy:c}=K(),{setModalData:w}=we(),{signTransaction:I}=Ve(),N=ze(),{user:O}=me(),{signWithUserSigner:p}=Je();return{signAndSendTransaction:async({transaction:A,address:S,chain:b="solana:mainnet",options:m})=>{let x=xe(O,S);if(x?.walletClientType!=="privy")throw new P("Wallet is not a Privy wallet",void 0,$.EMBEDDED_WALLET_NOT_FOUND);let f=Ce(x);async function _(C){if(m?.sponsor)return await(async v=>{if(!f)throw new P("Sponsoring transactions is only supported for wallets on the TEE stack",$.INVALID_DATA);let j=await Ye(c,p,{chain_type:"solana",method:"signAndSendTransaction",sponsor:!0,params:{transaction:he(v).toString("base64"),encoding:"base64"},caip2:`solana:${(await N(b).rpc.getGenesisHash().send()).substring(0,32)}`,wallet_id:x.id});if(j.data&&"hash"in j.data)return{signature:Ke.decode(j.data.hash)};throw Error("Failed to sign and send transaction")})(C);let{signedTransaction:M}=await I({transaction:C,address:S,chain:b,options:{...m,uiOptions:{...m?.uiOptions,showWalletUIs:!1}}}),{signature:g}=await N(b).sendAndConfirmTransaction(M);return{signature:g}}return r({showWalletUIs:m?.uiOptions?.showWalletUIs})?_(A):new Promise(async(C,M)=>{let g,v,{entropyId:j,entropyIdVerifier:R}=Fe(O,x);function k(G){return W=>{M(W instanceof P?W:new P("Failed to connect to wallet",W,G))}}let L={account:x,transaction:A,chain:b,signOnly:!1,uiOptions:m?.uiOptions||{},onConfirm:_,onSuccess:C,onFailure:k($.TRANSACTION_FAILURE),isSponsored:!!m?.sponsor},V={recoveryMethod:x.recoveryMethod,connectingWalletAddress:x.address,entropyId:j,entropyIdVerifier:R,isUnifiedWallet:f,onCompleteNavigateTo:"StandardSignAndSendTransactionScreen",onFailure:k($.UNKNOWN_CONNECT_WALLET_ERROR)};t.fundingConfig&&(g=At({address:S,appConfig:t,methodScreen:"FundingMethodSelectionScreen",fundWalletConfig:{...m,asset:"native-currency",chain:b},externalSolanaFundingScreen:"FundSolWalletWithExternalSolanaWallet"}),v={amount:t.fundingConfig.defaultRecommendedAmount,asset:"SOL",chain:b,destinationAddress:S,afterSuccessScreen:"StandardSignAndSendTransactionScreen",sourceWalletData:void 0}),w({connectWallet:V,standardSignAndSendTransaction:L,funding:g,solanaFundingData:v}),u("EmbeddedWalletConnectingScreen")})}}}(),o=y.useMemo(()=>{let t=[...yt(n).sort((u,c)=>(u.walletIndex??0)-(c.walletIndex??0))],r=vt(n);return r.length?[...t,...r]:t},[n]),i=y.useMemo(()=>({signMessage:async({message:t,address:r,options:u})=>await a({message:t,address:r,options:u}),signTransaction:async({transaction:t,address:r,chain:u,options:c})=>await l({transaction:t,address:r,chain:u,options:c}),async signAndSendTransaction({transaction:t,address:r,chain:u,options:c}){let{signature:w}=await d({transaction:t,address:r,chain:u,options:c});return{signature:w}}}),[a,l,d]);return y.useEffect(()=>{je?.setImplementation(i)},[i]),y.useEffect(()=>{var t;!e||(t=Ge.accounts).length===o.length&&t.every((r,u)=>r.address===o[u]?.address)||je?.emit("accountChanged",o)},[e,o]),{ready:e,wallet:Ge}}function zt(){let{client:e}=K(),{ready:n,wallet:a}=Kt(),[l,d]=y.useState([]),[o,i]=y.useState([]);return y.useEffect(()=>{let t=[a,...l.filter(c=>c.chainType==="solana"&&!!c.wallet.features).map(c=>c.wallet)];i(t);let r=l.flatMap(c=>{let w=()=>i([...t]);return c.on("walletsUpdated",w),{connector:c,off:w}}),u=t.map(c=>c.features["standard:events"]?.on("change",()=>{i([...t])}));return()=>{u.forEach(c=>c?.()),r.forEach(({connector:c,off:w})=>c.off("walletsUpdated",w))}},[l]),y.useEffect(()=>{d(e.connectors?.walletConnectors.filter(r=>r.chainType==="solana")??[]);let t=()=>{d(e.connectors?.walletConnectors.filter(r=>r.chainType==="solana")??[])};return e.connectors?.on("connectorInitialized",t),()=>{e.connectors?.off("connectorInitialized",t)}},[n,e.connectors]),{ready:n,wallets:o}}function Jt(){let{ready:e,wallets:n}=zt();return{ready:e,wallets:y.useMemo(()=>n.flatMap(a=>a.accounts.map(l=>new ht({wallet:a,account:l}))),[n])}}var Zt="11111111111111111111111111111111";function qt(e){if(!e)throw new Error("Expected a Address.");return typeof e=="object"&&"address"in e?e.address:Array.isArray(e)?e[0]:e}function Xt(e,n){return a=>{if(!a.value)return;const l=a.isWritable?Ue.WRITABLE:Ue.READONLY;return Object.freeze({address:qt(a.value),role:He(a.value)?Wt(l):l,...He(a.value)?{signer:a.value}:{}})}}function He(e){return!!e&&typeof e=="object"&&"address"in e&&xt(e)}var en=2;function tn(){return bt(Et([["discriminator",Ot()],["amount",jt()]]),e=>({...e,discriminator:en}))}function nn(e,n){const a=Zt,d={source:{value:e.source??null,isWritable:!0},destination:{value:e.destination??null,isWritable:!0}},o={...e},i=Xt();return Object.freeze({accounts:[i(d.source),i(d.destination)],data:tn().encode(o),programAddress:a})}function an({rows:e}){return h.jsx(ut,{children:e.filter(n=>!!n).map((n,a)=>n.value!=null||n.isLoading?h.jsxs(gt,{children:[h.jsx(ft,{children:n.label}),h.jsx(pt,{$isLoading:n.isLoading,children:n.value})]},a):null)})}function We(e){return BigInt(Math.floor(1e9*parseFloat(e)))}function Ee(e){return+sn.format(parseFloat(e.toString())/1e9)}let sn=Intl.NumberFormat(void 0,{maximumFractionDigits:8});async function rn({tx:e,solanaClient:n,amount:a,asset:l,tokenPrice:d}){if(!e)return null;if(l==="SOL"&&d){let o=We(a),i=fe(o,d),t=await pe({solanaClient:n,tx:e});return{amountInUsd:i,feeInUsd:d?fe(t,d):void 0,totalInUsd:fe(o+t,d)}}if(l==="USDC"&&d){let o="$"+a,i=await pe({solanaClient:n,tx:e}),t=function(r,u){let c=parseFloat(r.toString())/Nt*u;return c<.01?0:c}(i,d);return{amountInUsd:o,feeInUsd:fe(i,d),totalInUsd:"$"+(parseFloat(a)+t).toFixed(2)}}if(l==="SOL"){let o=We(a),i=await pe({solanaClient:n,tx:e});return{amountInSol:a+" SOL",feeInSol:Ee(i)+" SOL",totalInSol:Ee(o+i)+" SOL"}}return{amountInUsdc:a+" USDC",feeInSol:Ee(await pe({solanaClient:n,tx:e}))+" SOL"}}const jn={component:function(){let e=Qe(),{closePrivyModal:n,createAnalyticsEvent:a}=K(),{data:l,setModalData:d,navigate:o}=we(),{wallets:i}=Jt(),[t,r]=y.useState("preparing"),[u,c]=y.useState(),[w,I]=y.useState(),[N,O]=y.useState();if(!l?.solanaFundingData)throw Error("Funding config is missing");if(!l.solanaFundingData.sourceWalletData)throw Error("Funding config is missing source wallet data");let{amount:p,asset:A,chain:S,sourceWalletData:b,destinationAddress:m,afterSuccessScreen:x}=l.solanaFundingData,f=i.find(g=>g.address===b.address&&Pe(b.walletClientType)===Pe(g.standardWallet.name)),_=ze()(S),{tokenPrice:C,isTokenPriceLoading:M}=$t("solana");return y.useEffect(()=>{if(t!=="preparing"||M||!f)return;let g=A==="SOL"?We(p):function(v){return BigInt(Math.floor(1e6*parseFloat(v)))}(p);I({amount:(A==="SOL"&&C?fe(g,C):p)??p}),(A==="SOL"?async function({solanaClient:v,source:j,destination:R,amountInLamports:k}){let{value:L}=await v.rpc.getLatestBlockhash().send(),V={address:j},G=$e(Ne({version:0}),W=>Re(V,W),W=>Be(L,W),W=>Te(nn({amount:k,source:V,destination:R}),W),W=>Le(W));return new Uint8Array(Oe().encode(G))}({solanaClient:_,source:f.address,destination:m,amountInLamports:g}):async function({solanaClient:v,source:j,destination:R,amountInBaseUnits:k}){let L=Lt(v.chain),{value:V}=await v.rpc.getLatestBlockhash().send(),G={address:j},[W]=await De({mint:L,owner:j,tokenProgram:ke}),[Ae]=await De({mint:L,owner:R,tokenProgram:ke}),[Xe,et]=await Promise.all([v.rpc.getAccountInfo(W,{commitment:"confirmed",encoding:"jsonParsed"}).send().catch(()=>null),v.rpc.getAccountInfo(Ae,{commitment:"confirmed",encoding:"jsonParsed"}).send().catch(()=>null)]);if(!Xe?.value)throw Error(`Source token account does not exist for address: ${j}`);let tt=Ct({payer:G,ata:Ae,owner:R,mint:L}),nt=$e(Ne({version:0}),B=>Re(G,B),B=>Be(V,B),B=>et?.value?B:Te(tt,B),B=>Te(_t({source:W,destination:Ae,authority:G,amount:k}),B),B=>Le(B));return new Uint8Array(Oe().encode(nt))}({solanaClient:_,source:f.address,destination:m,amountInBaseUnits:g})).then(c).catch(v=>{r("error"),O(v)})},[t,p,A,S,f,m,M,C]),y.useEffect(()=>{t==="preparing"&&u&&rn({tx:u,solanaClient:_,amount:p,asset:A,tokenPrice:C}).then(g=>{r("loaded"),I({amount:g?.amountInUsd??g?.amountInUsdc??g?.amountInSol??p,fee:g?.feeInUsd??g?.feeInSol,total:g?.totalInUsd??g?.totalInSol})}).catch(g=>{r("error"),O(g)})},[u,p,A,t,C]),y.useEffect(()=>{t==="error"&&N&&(d({errorModalData:{error:N,previousScreen:"FundSolWalletWithExternalSolanaWallet"},solanaFundingData:l.solanaFundingData}),o("ErrorScreen",!1))},[t,o]),y.useEffect(()=>{if(t!=="success")return;let g=setTimeout(x?()=>o(x):n,Ft);return()=>clearTimeout(g)},[t]),h.jsxs(h.Fragment,t==="success"?{children:[h.jsx(ve,{}),h.jsx(it,{}),h.jsxs(rt,{children:[h.jsx(at,{color:"var(--privy-color-success)",width:"64px",height:"64px"}),h.jsx(Me,{title:"Success!",description:`Youâ€™ve successfully added ${p} ${A} to your ${e.name} wallet. It may take a minute before the funds are available to use.`})]}),h.jsx(ot,{}),h.jsx(ye,{})]}:t==="preparing"||t==="loaded"||t==="sending"?{children:[h.jsx(ve,{}),h.jsx(lt,{style:{marginTop:"16px"},children:h.jsx(ct,{icon:f?.standardWallet.icon,name:f?.standardWallet.name})}),h.jsx(Me,{style:{marginTop:"8px",marginBottom:"12px"},title:t==="sending"&&f?`Confirming with ${f.standardWallet.name}`:"Confirm transaction"}),h.jsx(an,{rows:[{label:"Source",value:Ie(b.address)},{label:"Destination",value:Ie(m)},{label:"Network",value:Bt(S)},{label:"Amount",value:w?.amount,isLoading:t==="preparing"},{label:"Estimated fee",value:w?.fee,isLoading:t==="preparing"},{label:"Total",value:w?.total,isLoading:t==="preparing"}]}),h.jsx(st,{style:{marginTop:"1rem"},loading:t==="preparing"||t==="sending",onClick:function(){t==="loaded"&&u&&f&&(r("sending"),async function({transaction:g,chain:v,sourceWallet:j,solanaClient:R}){let{hasFunds:k}=await Ut({solanaClient:R,tx:g});if(!k)throw new P(`Wallet ${Ie(j.address)} does not have enough funds.`,void 0,$.INSUFFICIENT_BALANCE);let L=Rt((await j.signAndSendTransaction({transaction:g,chain:v}).catch(V=>{throw new P("Transaction was rejected by the user",V,$.TRANSACTION_FAILURE)})).signature);return await Pt({rpcSubscriptions:R.rpcSubscriptions,signature:L,timeout:2e4}),L}({solanaClient:_,transaction:u,chain:S,sourceWallet:f}).then(g=>{r("success"),a({eventName:Dt,payload:{provider:"external",status:"success",txHash:g,address:f.address,value:p,chainType:"solana",clusterName:S,token:A,destinationAddress:m,destinationValue:p,destinationChainType:"solana",destinationClusterName:S,destinationToken:A}})}).catch(g=>{r("error"),O(g)}))},children:"Confirm"}),h.jsx(ye,{})]}:{children:[h.jsx(ve,{}),h.jsx(dt,{}),h.jsx("div",{style:{marginTop:"1rem"}}),h.jsx(ye,{})]})}};export{jn as FundSolWalletWithExternalSolanaWallet,jn as default};
