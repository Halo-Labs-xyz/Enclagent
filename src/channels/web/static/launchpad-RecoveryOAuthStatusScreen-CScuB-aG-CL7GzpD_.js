import{r as m,j as a}from"./launchpad.js";import{T as ne,m as H,u as de}from"./launchpad-ModalHeader-JjfRejxC-CtYe7KE2.js";import{o as B}from"./launchpad-ScreenHeader-CHmc4-Lu-B284yZ5R.js";import{dy as K,d4 as Y,d6 as G,d7 as se,dR as ue,dd as i,d9 as E,dT as X,dV as he,dJ as pe,du as ve,ef as we,ej as ye,ek as fe,el as me,em as Ee,en as _e,eo as ee,ep as Ae}from"./launchpad-App-CJN8YHj9.js";import{d as ge,e as Ce,o as J}from"./launchpad-styles-BsotlekN-CT8HbVkl.js";async function q({url:h,popup:c,provider:p}){return c.location=h,new Promise((l,n)=>{function d(){c?.close(),window.removeEventListener("message",s)}function s(o){o.data&&(o.data.type==="PRIVY_OAUTH_RESPONSE"&&o.data.stateCode&&o.data.authorizationCode&&(l(o.data),d()),o.origin==="https://cdn.apple-cloudkit.com"&&o.data.ckSession&&(l({type:"PRIVY_OAUTH_RESPONSE",ckWebAuthToken:o.data.ckSession}),d()),o.data.type==="PRIVY_OAUTH_ERROR"&&(n(o.data.error),d()))}window.addEventListener("message",s)})}async function Re({api:h,provider:c,stateCode:p,codeVerifier:l,authorizationCode:n}){if(!n||!p)throw new i("[OAuth AuthFlow] Authorization and state codes code must be set prior to calling authenicate.");if(n==="undefined")throw new i("User denied confirmation during OAuth flow");try{return(await h.post(Ae,{authorization_code:n,state_code:p,code_verifier:l,provider:c})).access_token}catch(d){let s=ee(d);throw s.privyErrorCode?new i(s.message||"Invalid code during OAuth flow.",void 0,s.privyErrorCode):s.message==="User denied confirmation during OAuth flow"?new i("Invalid code during oauth flow.",void 0,E.OAUTH_USER_DENIED):new i("Invalid code during OAuth flow.",void 0,E.UNKNOWN_AUTH_ERROR)}}async function Q({api:h,provider:c}){let p=ye(),l=fe(),n=await me(p);try{return c==="icloud"?{url:(await h.post(Ee,{client_type:"web"})).url}:{url:(await h.post(_e,{redirect_to:window.location.href,code_challenge:n,state_code:l})).url,codeVerifier:p,stateCode:l,provider:c}}catch(d){throw ee(d)}}let Z={"google-drive":{name:"Google Drive",component:Ce},icloud:{name:"iCloud",component:ge}};const Se={component:()=>{let{logout:h}=K(),{navigate:c,setModalData:p,data:l}=Y(),{closePrivyModal:n,createAnalyticsEvent:d}=G(),{execute:s}=(()=>{let{client:t,walletProxy:w,refreshSessionAndUser:N}=G(),{data:A}=Y(),{user:g}=K(),C=se(),{create:x}=ue();return{execute:async({provider:r,action:le,popup:P,shouldCreateEth:V,shouldCreateSol:L})=>{let R,y;if(!t)throw new i("Missing client");function F(e){if(!e&&t)throw t.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:"Unable to open recovery OAuth popup",provider:r}}),new i("Recovery OAuth failed")}switch(r){case"google-drive":{let e,u,{url:O,codeVerifier:b,stateCode:z}=await Q({api:t.api,provider:r});F(O);try{let k=await q({url:O,popup:P,provider:r});if(e=k.stateCode,u=k.authorizationCode,e!==z)throw t.createAnalyticsEvent({eventName:"possible_phishing_attempt",payload:{provider:r,storedStateCode:z??"",returnedStateCode:e??""}}),new i("Unexpected auth flow. This may be a phishing attempt.",void 0,E.OAUTH_UNEXPECTED)}catch(k){throw t.createAnalyticsEvent({eventName:"recovery_oauth_error",payload:{error:k.toString(),provider:r}}),new i("Recovery OAuth failed")}[R,y]=await Promise.all([t.getAccessToken(),Re({api:t.api,provider:r,codeVerifier:b,stateCode:e,authorizationCode:u})]);break}case"icloud":{let{url:e}=await Q({api:t.api,provider:r});F(e);let{ckWebAuthToken:u}=await q({url:e,popup:P,provider:r});y=u,R=await t.getAccessToken()}}if(!w)throw new i("Cannot connect to wallet proxy");if(!R)throw new i("Unable to authorize user");switch(le){case"recover":{let e=A?.recoverWallet?.entropyId,u=A?.recoverWallet?.entropyIdVerifier;if(!e||!u)throw new i("Recovery OAuth failed");t.createAnalyticsEvent({eventName:"embedded_wallet_recovery_started",payload:{walletAddress:e,recoveryMethod:r}}),await w.recover({accessToken:R,entropyId:e,entropyIdVerifier:u,recoveryAccessToken:y}),t.createAnalyticsEvent({eventName:"embedded_wallet_recovery_completed",payload:{walletAddress:e,recoveryMethod:r}});break}case"create-wallet":{let e;if(t.createAnalyticsEvent({eventName:"embedded_wallet_creation_started"}),V&&L)e=await x({recoveryMethod:r,recoveryAccessToken:y,chainType:"ethereum",walletIndex:0,latestUser:g}),e=await x({chainType:"solana",walletIndex:0,latestUser:e.user});else if(L)e=await x({recoveryMethod:r,recoveryAccessToken:y,chainType:"solana",walletIndex:0,latestUser:g});else{if(!V)throw Error("Invalid args to create wallet");e=await x({recoveryMethod:r,recoveryAccessToken:y,chainType:"ethereum",walletIndex:0,latestUser:g})}if(!e)throw C("createWallet","onError",E.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to create wallet");t.createAnalyticsEvent({eventName:"embedded_wallet_creation_completed",payload:{walletAddress:e.account.address}}),C("createWallet","onSuccess",{wallet:e.account});break}case"set-recovery":{let e=X(g);if(!e)throw C("setWalletRecovery","onError",E.EMBEDDED_WALLET_NOT_FOUND),Error("Embedded wallet not found");t.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_started",payload:{walletAddress:e.address,existingRecoveryMethod:e.recoveryMethod,targetRecoveryMethod:r}});let{entropyId:u,entropyIdVerifier:O}=he(g);await w.setRecovery({accessToken:R,entropyId:u,entropyIdVerifier:O,recoveryMethod:r,recoveryAccessToken:y});let b=X(await N());if(!b)throw C("createWallet","onError",E.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to set recovery on wallet");t.createAnalyticsEvent({eventName:"embedded_wallet_set_recovery_completed",payload:{walletAddress:e.address,existingRecoveryMethod:e.recoveryMethod,targetRecoveryMethod:r}}),C("setWalletRecovery","onSuccess",{method:r,wallet:b});break}default:throw new i("Unsupported recovery action")}}}})(),[o,I]=m.useState(!1),{provider:_,action:f,isInAccountCreateFlow:U,shouldCreateEth:te,shouldCreateSol:re}=l?.recoveryOAuthStatus,[v,M]=m.useState(void 0),[oe,ae]=m.useState(f==="create-wallet");if(_==="user-passcode")throw Error("RecoveryOAuthScreen should never be called with a wallet that specifies recoveryMethod: `user-passcode`");let W=Z[_].name,$=Z[_].component,D=l?.recoverWallet?.onCompleteNavigateTo,S=new pe(async(t="create-wallet")=>(ae(!0),new Promise((w,N)=>{setTimeout(async()=>{try{let A=window.open();await s({provider:_,action:t,popup:A,shouldCreateEth:te,shouldCreateSol:re}),I(!0),w()}catch{M({message:`${t==="recover"?"Recovery":"Back up"} with ${W} unsuccessful`,detail:f==="recover"?`Please verify that you are selecting the ${W} account associated with your backup.`:"",retryable:!0}),N()}},0)})));m.useEffect(()=>{f!=="recover"&&S.execute(U?"create-wallet":"set-recovery")},[]),m.useEffect(()=>{if(!o)return;let t=setTimeout(()=>{U?(p({createWallet:{onSuccess:()=>{},onFailure:w=>{d({eventName:"embedded_wallet_creation_failure_logout",payload:{error:w,screen:"RecoveryOAuthScreen"}}),h()},callAuthOnSuccessOnClose:!0,shouldCreateEth:!1,shouldCreateSol:!1}}),c("EmbeddedWalletCreatedScreen")):n({shouldCallAuthOnSuccess:!1})},ve);return()=>clearTimeout(t)},[o]);let j=m.useCallback(async()=>{await S.execute("recover"),D?c(D):I(!0)},[]),T=_==="google-drive"?"Google Drive":"Apple iCloud",ie=o&&`Successfully ${f==="recover"?"recovered":"backed up"} with ${T}.`||v&&v.message||`${f==="recover"?"Recovering":"Backing up"} with ${T}...`,ce=v?v.detail:"";return a.jsxs(a.Fragment,{children:[a.jsx(ne,{}),oe?a.jsx(a.Fragment,{children:a.jsxs(J,{children:[a.jsx(B,{title:ie,icon:a.jsx($,{style:{width:"38px",height:"38px"}}),description:ce}),v&&v?.retryable?a.jsx(H,{onClick:()=>{we(),M(void 0),f==="create-wallet"?S.execute("create-wallet"):j()},disabled:!o&&!v?.retryable,children:"Try again"}):null]})}):a.jsxs(J,{children:[a.jsx(B,{title:"Confirm it's really you",icon:a.jsx($,{style:{height:42,width:48}}),description:`To confirm your identity, please log in to ${T} where your account is backed up.`}),a.jsxs(H,{onClick:j,children:["Confirm with ",T]})]}),a.jsx(de,{})]})}};export{Se as RecoveryOAuthScreen,Se as default};
